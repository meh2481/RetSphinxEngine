Current higher pri:
- Vulkan
- atexit() flush & close log file, so even on crash we have a full logfile? Is that how that works?
- FMOD 3D sound
    - Objects can have their own sfx associated with them (channel group)
	- Change listener up/forward vectors with head tracker for fun
	- Large objects are registered as FMOD geometry
- Make logger threadsafe
- Cache should keep object length, should have a maximum size that's time-rotated as new entries are made. Not cleared on level load.
		
- Load Music from pak? Need to stream from disk
- Particle with x that tapers to points (anime-style) - also see star lens flares on space photos
- Timestamp-based asset rebuilding; only rebuild changed assets, repack everything else around it
- clear log after every day? Zip logs? Etc
- Assets in pak files according to levels/chunks; all assets in one chunk are loaded at once
	- Automatically walk dependency chain to get used assets per chunk / manually specify?
	- Need some way of building out levels/chunks automatically, or more easy way to do it manually
	- Potentially can export current resources via keypress or something like that; requires pak to have been hit for all tho
		-If so, large errors like error textures etc. for when a miss happens (as described in talk). These will have to be stubbed out for final game
	- Think about tree structure for asset dependencies, pros/cons
- Better handling of raw vs. DXT images for compression - need to be able to specify which you want
- Compressor should be multithreaded
- Small-block memory allocator for Lua
	- Other memory allocators/uses?
- Objects
	- Objects stored as binary files, not XML
		- Templated so that complicated setup work doesn't have to be done every time (like Lua class loading)
	- Objects stored in folder with:
		- Lua
		- Segments
			- Box2D Fixtures
			- Images/3D meshes
			- Sound geometry (Only on level geometry/large objects)
			- Shaders
			- Animation frame sequences/reskins
		- Sound references
		- Properties (for Lua instantiation)
		- Box2D constraints/joints/etc
		- Animations
- Save/Load state on game exit/launch (and periodically)
	- Music & music position
	- Current level, position, enemy location, geometry
	- Current cutscene/dialogue (prolly restart these from beginning)
	- Quicksaves should be interruptable without failure/save loss
	- Ways to fast travel/reset map so that softlocks can be avoided

- Particles follow ship with acceleration applied
- Use level editor to create geometry/scenery
- Fix tamerisk board
- Better handling of object reskinning than obj_setImage from lua

Bugs:
- Physics engine tied to framerate; 144Hz same # of physics engine cycles as 60Hz per frame
- Setting fps to 144 in config and then running on 60fps monitor causes game to be slow
- Ship stops suddenly when moving joystick slowly towards center position
- Particle editor breaks after F5
- Fix objsegment partial tiling? Or do I not care?
- Adding to a pak .txt doesn't check that the pak contains said files; just says up-to-date

Possible sound channels:
- BGM
- SFX
- Environmental SFX
- System SFX
- Voice
- Bg voice
- Movie

Overall TODO list:
- Research FMOD Studio & what I could do with that
- Revisit class predeclaration and add more where possible
- Curve editor via ImGUI
- Resources should be streamed from disk?
- Use shaders for lattice-based animations
- Ortho for HUD and text drawing
- Error checking of parameters in luafuncs.cpp (without breaking everything this time)

Particle System Editing:
- UI should save/load window booleans as config
- Re-add death spawn types (tho prolly on a per-system basis?)
- Add particle support for emitter acceleration
- Add support for seeing particle death spawns
- Add rotation angle for setting rotation based on velocity (so you don't have to image edit for a particle problem)

Lower priority:
- "Press Any Key" in games is used to determine which controller to use (though this should be stored, which most games don't do)
- UTF code point lookup should use array of direct values rather than binary search? Or hashmap of some sort?
- Use SDL_GetPowerInfo() for laptop battery reminders
- Move all resource loading stuff to IO?

Reasoning behind the engine design (aka why not just use Unity or whatever):
- Robust Lua scripting interface
- 3D either fleshed out more fully (with sub-objects, object demolition) or ripped out
	-- Don't want to bother with bones/3D animation; math too complicated. Does this make the 3D too limited?
	-- How much do I care about 3D eye candy and does that just make the 2D stuff look like crap?
- Simplified resource managment
	-- Paged in with memory mapping if intelligent enough for performance gains
- XML vs. Lua - when to use one over the other? Can XML be removed intelligently?
- Optimization and data-driven programming/design where applicable
- I had a look at Unity; it sucks all the joy out of game development
	- Low-level code (the fun part) is replaced with high-level APIs to learn. Learning APIs is not fun, and never will be.
	- Actual learning as a whole is removed; you won't learn anything practical from learning Unity
	- No programming experience is required in Unity; any old artist can throw something together that will look better. Lack of art skill will become the major limiting factor.
	- Unity uses C#. C# is a terrible language made by novices, for novices
	- The "portability" aspect is thrown out the window when optimization is difficult. New Unity projects can't be ported to Vita. Old ones could, but were incredibly impossible to optimize (because C#). In essence, using a "more portable" platform prevents actual portability, and optimizing per-system is nigh on impossible. A render method that's fast on one system may be impossibly slow on another, and Unity can't take this into account as well as a well-designed, lower-level engine can (because C#).


Other misc unordered TODO:
- Scene editor / XML exporter
- Intelligently split things into subclasses




For Windows release build:
- Flip Box2D lib to release lib (via cmake)
- Fix release mode having such a weird long loading time thing





	
-GLM for math
	- mat4 for transformations
	v' = mat4 * (x,y,z,0) --> transform vector
	v' = mat4 * (x,y,z,1) --> transforms point (translate)
	m = scale * translate * rot --> rotate first, then translate, then scale
	projmat = cameramat * objmat (can be recursive by passing proj to child objects)
	
Endianness testing:
	union { char c[2], short s; } u; u.s = 1; return u.c[0];
	
	
Note: On Linux, "xboxdrv" is the driver I had the most success with when it came to gamepad rumble (default driver said it rumbled, but didn't)

@fgenesis | debug.traceback() in a xpcall() handler at least
@fgenesis | so if stuff breaks you know why
@fgenesis | i think my Lua C++ api already does this for C++->Lua calls

Also add lua error stuff to log as well as cmdline, only cmdline if in debug mode