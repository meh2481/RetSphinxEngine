Overall TODO list:
- Fix math for softbody lattice anim so it actually works properly
- Use GLM for math stuff instead of glPushMatrix() and friends
- Implement newer OpenGL shaders
- Use shaders rather than lattice animations where possible
- IO in separate thread?
- Disable exceptions/rtti?
- rip out displaylists for 3D objects and use vertex buffers instead
- class predeclaration where possible
- Ortho for HUD
- Create allocator / choose one to use rather than mixing malloc & new
- Decide if map loading is engine-specific or game-specific
- Particle systems, objects, etc should be loaded by template, not from XML each time
- Move all resource loading stuff to IO?
- Move object self-creation into resource loaders where applicable
- Revisit joystick support - support multiple controllers, switching input modes, etc
- Support SDL joystick also if gamecontroller isn't opened - see my SNES knockoff
- Error checking of parameters in luafuncs.cpp (without breaking everything this time)
- "Press Any Key" in games is used to determine which controller to use (though this should be stored, which most games don't do)


Refactoring thoughts:
- Image class is bloated with too much junk; once shaders are implemented see what can be cropped out
- lots of classes are in files for other classes; move to own files



Reasoning behind the engine design (aka why not just use Unity or whatever):
- Robust Lua scripting interface
- 3D either fleshed out more fully (with sub-objects, object demolition) or ripped out
	-- Don't want to bother with bones/3D animation; math too complicated. Does this make the 3D too limited?
	-- How much do I care about 3D eye candy and does that just make the 2D stuff look like crap?
- Simplified resource managment
	-- Paged in with memory mapping if intelligent enough for performance gains
- XML vs. Lua - when to use one over the other? Can XML be removed intelligently?
- Optimization and data-driven programming/design where applicable



Other misc unordered TODO:
- Scene editor / XML exporter
- Intelligently split things into subclasses







OPENGL STUFF

- glNamedBufferStorageEXT()
https://www.opengl.org/wiki/Nomenclature/Direct_State_Access
https://dl.dropboxusercontent.com/u/22111385/crap/renderer.cpp
- glUniformX() functions for sending stuff to shaders
- Load from pakfile only if actual file doesn't exist
https://dl.dropboxusercontent.com/u/22111385/crap/correlation_lines.vert
https://dl.dropboxusercontent.com/u/22111385/crap/correlation_lines.frag
https://dl.dropboxusercontent.com/u/22111385/crap/gpubase.7z







SafeShaderVar sv[] =
{
{ "proj", as_uniform(proj) },
{ "tex", as_uniform(textureUnit) },
{ "rayExitTex", as_uniform(textureUnitBack) },
{ "samplingDist", as_uniform(vrp.samplingDist) },
{ "stepValue", as_uniform(vrp.stepValue) },
{ "deformTex", as_uniform(textureUnitDeform) },
{ "intensity", as_uniform(vrp.intensity) },
{ "alphaMult", as_uniform(vrp.alphaMult) },
{ "colorTex", as_uniform(textureUnitColor) },
{ "deformMult", as_uniform(vrp.deformMult) },
};

shader->setUniforms(sv);












notes from talk with fg:
- if GL 4.5 if(glDebugMessageCallback) - GL_DEBUG_OUTPUT_SYNCHRONOUS
	-- set core profile SDL_GL_CONTEXT_PROFILE_CORE
	-- gontext)forward_compatible_flag | sdl_gl_context debug_flag
	--SDL_GL_SHARE_WITH_CURRENT_CONTEXT
	
-GLM for math
	- mat4 for transformations
	v' = mat4 * (x,y,z,0) --> transform vector
	v' = mat4 * (x,y,z,1) --> transforms point (translate)
	m = scale * translate * rot --> rotate first, then translate, then scale
	projmat = cameramat * objmat (can be recursive by passing proj to child objects)
	
Endianness testing:
	union { char c[2], short s; } u; u.s = 1; return u.c[0];
	
	
Note: On Linux, "xboxdrv" is the driver I had the most success with when it came to gamepad rumble (default driver said it rumbled, but didn't)